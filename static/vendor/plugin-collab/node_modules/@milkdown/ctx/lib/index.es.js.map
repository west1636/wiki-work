{"version":3,"file":"index.es.js","sources":["../src/context/container.ts","../src/context/slice.ts","../src/inspector/inspector.ts","../src/plugin/ctx.ts","../src/timer/clock.ts","../src/timer/timer.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport { contextNotFound } from '@milkdown/exception'\n\nimport type { Slice, SliceType } from './slice'\n\n/// @internal\nexport type SliceMap = Map<symbol, Slice>\n\n/// Container is a map of slices.\nexport class Container {\n  /// @internal\n  sliceMap: SliceMap = new Map()\n\n  /// Get a slice from the container by slice type or slice name.\n  get = <T, N extends string = string>(slice: SliceType<T, N> | N): Slice<T, N> => {\n    const context = typeof slice === 'string'\n      ? [...this.sliceMap.values()].find(x => x.type.name === slice)\n      : this.sliceMap.get(slice.id)\n\n    if (!context) {\n      const name = typeof slice === 'string' ? slice : slice.name\n      throw contextNotFound(name)\n    }\n    return context as Slice<T, N>\n  }\n\n  /// Remove a slice from the container by slice type or slice name.\n  remove = <T, N extends string = string>(slice: SliceType<T, N> | N): void => {\n    const context = typeof slice === 'string'\n      ? [...this.sliceMap.values()].find(x => x.type.name === slice)\n      : this.sliceMap.get(slice.id)\n\n    if (!context)\n      return\n\n    this.sliceMap.delete(context.type.id)\n  }\n\n  /// Check if the container has a slice by slice type or slice name.\n  has = <T, N extends string = string>(slice: SliceType<T, N> | N): boolean => {\n    if (typeof slice === 'string')\n      return [...this.sliceMap.values()].some(x => x.type.name === slice)\n\n    return this.sliceMap.has(slice.id)\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { ctxCallOutOfScope } from '@milkdown/exception'\nimport type { SliceMap } from './container'\n\n/// Slice is a value of slice type.\nexport class Slice<T = any, N extends string = string> {\n  /// The type of the slice.\n  readonly type: SliceType<T, N>\n\n  /// @internal\n  #watchers: Array<(value: T) => unknown> = []\n\n  /// @internal\n  #value: T\n\n  /// @internal\n  #emit = () => {\n    this.#watchers.forEach(watcher => watcher(this.#value))\n  }\n\n  /// @internal\n  constructor(container: SliceMap, value: T, type: SliceType<T, N>) {\n    this.type = type\n    this.#value = value\n    container.set(type.id, this)\n  }\n\n  /// Add a watcher for changes in the slice.\n  /// Returns a function to remove the watcher.\n  on(watcher: (value: T) => unknown) {\n    this.#watchers.push(watcher)\n    return () => {\n      this.#watchers = this.#watchers.filter(w => w !== watcher)\n    }\n  }\n\n  /// Add a one-time watcher for changes in the slice.\n  /// The watcher will be removed after it is called.\n  /// Returns a function to remove the watcher.\n  once(watcher: (value: T) => unknown) {\n    const off = this.on((value) => {\n      watcher(value)\n      off()\n    })\n    return off\n  }\n\n  /// Remove a watcher.\n  off(watcher: (value: T) => unknown) {\n    this.#watchers = this.#watchers.filter(w => w !== watcher)\n  }\n\n  /// Remove all watchers.\n  offAll() {\n    this.#watchers = []\n  }\n\n  /// Set the value of the slice.\n  set = (value: T) => {\n    this.#value = value\n    this.#emit()\n  }\n\n  /// Get the value of the slice.\n  get = () => this.#value\n\n  /// Update the value of the slice with a callback.\n  update = (updater: (prev: T) => T) => {\n    this.#value = updater(this.#value)\n    this.#emit()\n  }\n}\n\n/// Slice type can be used to create slices in different containers.\nexport class SliceType<T = any, N extends string = string> {\n  /// The unique id of the slice type.\n  readonly id: symbol\n  /// The name of the slice type.\n  readonly name: N\n  /// @internal\n  readonly _typeInfo: () => T\n  /// @internal\n  readonly _defaultValue: T\n\n  /// Create a slice type with a default value and a name.\n  /// The name should be unique in the container.\n  constructor(value: T, name: N) {\n    this.id = Symbol(`Context-${name}`)\n    this.name = name\n    this._defaultValue = value\n    this._typeInfo = (): T => {\n      throw ctxCallOutOfScope()\n    }\n  }\n\n  /// Create a slice with a container.\n  /// You can also pass a value to override the default value.\n  create(container: SliceMap, value: T = this._defaultValue): Slice<T, N> {\n    return new Slice(container, value, this)\n  }\n}\n\n/// Create a slice type with a default value and a name.\n/// This is equivalent to `new SliceType(value, name)`.\nexport const createSlice = <T = any, N extends string = string>(value: T, name: N) => new SliceType(value, name)\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Container, SliceType } from '../context'\nimport type { Clock, TimerStatus, TimerType } from '../timer'\nimport type { Meta } from './meta'\n\nexport interface Telemetry {\n  metadata: Meta\n  injectedSlices: { name: string, value: unknown }[]\n  consumedSlices: { name: string, value: unknown }[]\n  recordedTimers: { name: string, duration: number, status: TimerStatus }[]\n  waitTimers: { name: string, duration: number, status: TimerStatus }[]\n}\n\n/// The inspector object that is used to inspect the runtime environment of a ctx.\nexport class Inspector {\n  /// @internal\n  readonly #meta: Meta\n\n  /// @internal\n  readonly #container: Container\n\n  /// @internal\n  readonly #clock: Clock\n\n  /// @internal\n  readonly #injectedSlices: Set<SliceType | string> = new Set()\n\n  /// @internal\n  readonly #consumedSlices: Set<SliceType | string> = new Set()\n\n  /// @internal\n  readonly #recordedTimers: Map<TimerType, { duration: number, start: number }> = new Map()\n\n  /// @internal\n  readonly #waitTimers: Map<TimerType, { duration: number }> = new Map()\n\n  /// Create an inspector with container, clock and metadata.\n  constructor(\n    container: Container,\n    clock: Clock,\n    meta: Meta,\n  ) {\n    this.#container = container\n    this.#clock = clock\n    this.#meta = meta\n  }\n\n  /// Read the runtime telemetry as an object of the ctx.\n  read = (): Telemetry => {\n    return {\n      metadata: this.#meta,\n      injectedSlices: [...this.#injectedSlices].map(slice => ({\n        name: typeof slice === 'string' ? slice : slice.name,\n        value: this.#getSlice(slice),\n      })),\n      consumedSlices: [...this.#consumedSlices].map(slice => ({\n        name: typeof slice === 'string' ? slice : slice.name,\n        value: this.#getSlice(slice),\n      })),\n      recordedTimers: [...this.#recordedTimers].map(([timer, { duration }]) => ({\n        name: timer.name,\n        duration,\n        status: this.#getTimer(timer),\n      })),\n      waitTimers: [...this.#waitTimers].map(([timer, { duration }]) => ({\n        name: timer.name,\n        duration,\n        status: this.#getTimer(timer),\n      })),\n    }\n  }\n\n  /// @internal\n  readonly onRecord = (timerType: TimerType) => {\n    this.#recordedTimers.set(timerType, { start: Date.now(), duration: 0 })\n  }\n\n  /// @internal\n  readonly onClear = (timerType: TimerType) => {\n    this.#recordedTimers.delete(timerType)\n  }\n\n  /// @internal\n  readonly onDone = (timerType: TimerType) => {\n    const timer = this.#recordedTimers.get(timerType)\n    if (!timer)\n      return\n    timer.duration = Date.now() - timer.start\n  }\n\n  /// @internal\n  readonly onWait = (timerType: TimerType, promise: Promise<void>) => {\n    const start = Date.now()\n    promise.finally(() => {\n      this.#waitTimers.set(timerType, { duration: Date.now() - start })\n    })\n  }\n\n  /// @internal\n  readonly onInject = (sliceType: SliceType | string) => {\n    this.#injectedSlices.add(sliceType)\n  }\n\n  /// @internal\n  readonly onRemove = (sliceType: SliceType | string) => {\n    this.#injectedSlices.delete(sliceType)\n  }\n\n  /// @internal\n  readonly onUse = (sliceType: SliceType | string) => {\n    this.#consumedSlices.add(sliceType)\n  }\n\n  /// @internal\n  #getSlice = (sliceType: SliceType | string) => {\n    return this.#container.get(sliceType).get()\n  }\n\n  /// @internal\n  #getTimer = (timerType: TimerType) => {\n    return this.#clock.get(timerType).status\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Container, Slice, SliceType } from '../context'\nimport type { Clock, TimerType } from '../timer'\nimport { Inspector } from '../inspector'\nimport type { Meta } from '../inspector'\n\n/// The ctx object that can be accessed in plugin and action.\nexport class Ctx {\n  /// @internal\n  readonly #container: Container\n  /// @internal\n  readonly #clock: Clock\n  /// @internal\n  readonly #meta?: Meta\n  /// @internal\n  readonly #inspector?: Inspector\n\n  /// Create a ctx object with container and clock.\n  constructor(container: Container, clock: Clock, meta?: Meta) {\n    this.#container = container\n    this.#clock = clock\n    this.#meta = meta\n    if (meta)\n      this.#inspector = new Inspector(container, clock, meta)\n  }\n\n  /// Get metadata of the ctx.\n  get meta() {\n    return this.#meta\n  }\n\n  /// Get the inspector of the ctx.\n  get inspector() {\n    return this.#inspector\n  }\n\n  /// Produce a new ctx with metadata.\n  /// The new ctx will link to the same container and clock with the current ctx.\n  /// If the metadata is empty, it will return the current ctx.\n  readonly produce = (meta?: Meta) => {\n    if (meta && Object.keys(meta).length)\n      return new Ctx(this.#container, this.#clock, { ...meta })\n\n    return this\n  }\n\n  /// Add a slice into the ctx.\n  readonly inject = <T>(sliceType: SliceType<T>, value?: T) => {\n    const slice = sliceType.create(this.#container.sliceMap)\n    if (value != null)\n      slice.set(value)\n\n    this.#inspector?.onInject(sliceType)\n\n    return this\n  }\n\n  /// Remove a slice from the ctx.\n  readonly remove = <T, N extends string = string>(sliceType: SliceType<T, N> | N) => {\n    this.#container.remove(sliceType)\n    this.#inspector?.onRemove(sliceType)\n    return this\n  }\n\n  /// Add a timer into the ctx.\n  readonly record = (timerType: TimerType) => {\n    timerType.create(this.#clock.store)\n    this.#inspector?.onRecord(timerType)\n    return this\n  }\n\n  /// Remove a timer from the ctx.\n  readonly clearTimer = (timerType: TimerType) => {\n    this.#clock.remove(timerType)\n    this.#inspector?.onClear(timerType)\n    return this\n  }\n\n  /// Check if the ctx has a slice.\n  readonly isInjected = <T, N extends string = string>(sliceType: SliceType<T, N> | N) => this.#container.has(sliceType)\n\n  /// Check if the ctx has a timer.\n  readonly isRecorded = (timerType: TimerType) => this.#clock.has(timerType)\n\n  /// Get a slice from the ctx.\n  readonly use = <T, N extends string = string>(sliceType: SliceType<T, N> | N): Slice<T, N> => {\n    this.#inspector?.onUse(sliceType)\n    return this.#container.get(sliceType)\n  }\n\n  /// Get a slice value from the ctx.\n  readonly get = <T, N extends string>(sliceType: SliceType<T, N> | N) => this.use(sliceType).get()\n\n  /// Get a slice value from the ctx.\n  readonly set = <T, N extends string>(sliceType: SliceType<T, N> | N, value: T) => this.use(sliceType).set(value)\n\n  /// Update a slice value from the ctx by a callback.\n  readonly update = <T, N extends string>(sliceType: SliceType<T, N> | N, updater: (prev: T) => T) => this.use(sliceType).update(updater)\n\n  /// Get a timer from the ctx.\n  readonly timer = (timer: TimerType) => this.#clock.get(timer)\n\n  /// Resolve a timer from the ctx.\n  readonly done = (timer: TimerType) => {\n    this.timer(timer).done()\n    this.#inspector?.onDone(timer)\n  }\n\n  /// Start a timer from the ctx.\n  readonly wait = (timer: TimerType) => {\n    const promise = this.timer(timer).start()\n    this.#inspector?.onWait(timer, promise)\n    return promise\n  }\n\n  /// Start a list of timers from the ctx, the list is stored in a slice in the ctx.\n  /// This is equivalent to\n  ///\n  /// ```typescript\n  /// Promise.all(ctx.get(slice).map(x => ctx.wait(x))).\n  /// ```\n  readonly waitTimers = async (slice: SliceType<TimerType[]>) => {\n    await Promise.all(this.get(slice).map(x => this.wait(x)))\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { timerNotFound } from '@milkdown/exception'\n\nimport type { Timer, TimerType } from './timer'\n\n/// @internal\nexport type TimerMap = Map<symbol, Timer>\n\n/// Container is a map of timers.\nexport class Clock {\n  /// @internal\n  readonly store: TimerMap = new Map()\n\n  /// Get a timer from the clock by timer type.\n  get = (timer: TimerType) => {\n    const meta = this.store.get(timer.id)\n    if (!meta)\n      throw timerNotFound(timer.name)\n    return meta\n  }\n\n  /// Remove a timer from the clock by timer type.\n  remove = (timer: TimerType) => {\n    this.store.delete(timer.id)\n  }\n\n  // Check if the clock has a timer by timer type.\n  has = (timer: TimerType) => {\n    return this.store.has(timer.id)\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { TimerMap } from './clock'\n\nexport type TimerStatus = 'pending' | 'resolved' | 'rejected'\n\n/// Timer is a promise that can be resolved by calling done.\nexport class Timer {\n  /// The type of the timer.\n  readonly type: TimerType\n\n  /// @internal\n  #promise: Promise<void> | null = null\n  /// @internal\n  #listener: EventListener | null = null\n  /// @internal\n  readonly #eventUniqId: symbol\n  /// @internal\n  #status: TimerStatus = 'pending'\n\n  /// @internal\n  constructor(clock: TimerMap, type: TimerType) {\n    this.#eventUniqId = Symbol(type.name)\n    this.type = type\n    clock.set(type.id, this)\n  }\n\n  /// The status of the timer.\n  /// Can be `pending`, `resolved` or `rejected`.\n  get status() {\n    return this.#status\n  }\n\n  /// Start the timer, which will return a promise.\n  /// If the timer is already started, it will return the same promise.\n  /// If the timer is not resolved in the timeout, it will reject the promise.\n  start = () => {\n    this.#promise ??= new Promise((resolve, reject) => {\n      this.#listener = (e: Event) => {\n        if (!(e instanceof CustomEvent))\n          return\n\n        if (e.detail.id === this.#eventUniqId) {\n          this.#status = 'resolved'\n          this.#removeListener()\n          e.stopImmediatePropagation()\n          resolve()\n        }\n      }\n\n      this.#waitTimeout(() => {\n        if (this.#status === 'pending')\n          this.#status = 'rejected'\n\n        this.#removeListener()\n        reject(new Error(`Timing ${this.type.name} timeout.`))\n      })\n\n      this.#status = 'pending'\n      addEventListener(this.type.name, this.#listener)\n    })\n\n    return this.#promise\n  }\n\n  /// Resolve the timer.\n  done = () => {\n    const event = new CustomEvent(this.type.name, { detail: { id: this.#eventUniqId } })\n    dispatchEvent(event)\n  }\n\n  /// @internal\n  #removeListener = () => {\n    if (this.#listener)\n      removeEventListener(this.type.name, this.#listener)\n  }\n\n  /// @internal\n  #waitTimeout = (ifTimeout: () => void) => {\n    setTimeout(() => {\n      ifTimeout()\n    }, this.type.timeout)\n  }\n}\n\n/// Timer type can be used to create timers in different clocks.\nexport class TimerType {\n  /// The unique id of the timer type.\n  readonly id: symbol\n  /// The name of the timer type.\n  readonly name: string\n  /// The timeout of the timer type.\n  readonly timeout: number\n\n  /// Create a timer type with a name and a timeout.\n  /// The name should be unique in the clock.\n  constructor(name: string, timeout = 3000) {\n    this.id = Symbol(`Timer-${name}`)\n    this.name = name\n    this.timeout = timeout\n  }\n\n  /// Create a timer with a clock.\n  create = (clock: TimerMap): Timer => {\n    return new Timer(clock, this)\n  }\n}\n\n/// Create a timer type with a name and a timeout.\n/// This is equivalent to `new TimerType(name, timeout)`.\nexport const createTimer = (name: string, timeout = 3000) => new TimerType(name, timeout)\n"],"names":["Container","slice","context","x","name","contextNotFound","Slice","container","value","type","__privateAdd","_watchers","_value","_emit","__privateSet","__privateGet","watcher","updater","w","off","SliceType","ctxCallOutOfScope","createSlice","Inspector","clock","meta","_meta","_container","_clock","_injectedSlices","_consumedSlices","_recordedTimers","_waitTimers","_getSlice","_getTimer","timer","duration","timerType","promise","start","sliceType","_Ctx","_inspector","_a","Ctx","Clock","timerNotFound","Timer","_promise","_listener","_eventUniqId","_status","_removeListener","_waitTimeout","resolve","reject","e","event","ifTimeout","TimerType","timeout","createTimer"],"mappings":"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"}